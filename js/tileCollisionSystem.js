// Generated by CoffeeScript 1.8.0
(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  define(['entityProcessingSystem', 'vector'], function(EntityProcessingSystem, Vector) {
    var TileCollisionSystem;
    return TileCollisionSystem = (function(_super) {
      __extends(TileCollisionSystem, _super);

      function TileCollisionSystem(map) {
        this.map = map;
        this.processEntity = __bind(this.processEntity, this);
        TileCollisionSystem.__super__.constructor.call(this, ['position', 'velocity']);
      }

      TileCollisionSystem.prototype.processEntity = function(e, dt) {
        var chunk, chunkPos, log, p, tile, tilePos, v, _ref, _ref1;
        p = e.position.vector;
        v = e.velocity.vector;
        chunkPos = this.map.toChunkOffset(p).sub(this.map.position);
        chunk = (_ref = this.map.chunks[chunkPos.x]) != null ? _ref[chunkPos.y] : void 0;
        if (chunk == null) {
          return;
        }
        tilePos = chunk.toTileOffset(p);
        tile = (_ref1 = chunk.tiles[tilePos.x]) != null ? _ref1[tilePos.y] : void 0;
        if (tile == null) {
          console.log("invalid tile index" + tilePos.x + ", " + tilePos.y + " (chunk pos: " + chunk.tiles[0][0].pos.x + ", " + chunk.tiles[0][0].pos.y + ") in chunk " + chunkPos.x + ", " + chunkPos.y + ": entity at " + p.x + ", " + p.y);
          return;
        }
        log = Math.random() > 0.01;
        if (tile.isWall) {

          /*
          tmp = new Vector(tile.pos).add(tile.size/2, tile.size/2)
          tmp.sub(p).mul(-1)
          
          if(log)
            console.log "diff: (#{tmp.x}, #{tmp.y})"
           */

          /*
          tmp = new Vector(v).mul(-1)
          
          offset = 10
          if Math.abs(tmp.x) > Math.abs(tmp.y)
            if(tmp.x>0)
              tmp.x = tile.pos.x + tile.size - p.x + offset
            else
              tmp.x = tile.pos.x - p.x - offset
            tmp.y = 0
          else
            tmp.x = 0
            if(tmp.y>0)
              tmp.y = tile.pos.y + tile.size - p.y + offset
            else
              tmp.y = tile.pos.y - p.y - offset
          
          if(log)
            console.log "pushing + (#{tmp.x}, #{tmp.y})"
           * move
          p.add tmp
           */
          return p.add(new Vector(v).mul(-dt));
        }
      };


      /*
      lineLineIntersect: (p0, d0, p1, d1) ->
        tmp = new Vector()
        tmp.set(d0).sub d1
        if tmp.lengthSquared < 0.01
          return null #parallel
          
        return tmp.set (
       */

      return TileCollisionSystem;

    })(EntityProcessingSystem);
  });

}).call(this);
