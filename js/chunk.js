// Generated by CoffeeScript 1.8.0
(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  define(["vector", "tile"], function(Vector, Tile) {
    var Chunk;
    return Chunk = (function() {

      /*
       * creates a chunk with level information
       * @param  {vec2} @offset (chunk) offset of the chunk
       * @param  {int} @dimension   number of tiles on each axis
       * @param {int} @tilesize size of tiles
       * @param  {chunkGenerator} @chunkGen class to create tiles
       */
      function Chunk(offset, dimension, tilesize, chunkGen, gameContainer) {
        var chunkVec, posPerChunk, x, y, _i, _j, _k, _l, _ref, _ref1, _ref2, _ref3, _results, _results1;
        this.offset = offset;
        this.dimension = dimension;
        this.tilesize = tilesize;
        this.chunkGen = chunkGen;
        this.gameContainer = gameContainer;
        this.toTileOffset = __bind(this.toTileOffset, this);
        this.tiles = [];
        this.tiles = (function() {
          _results = [];
          for (var _i = 0, _ref = this.dimension; 0 <= _ref ? _i < _ref : _i > _ref; 0 <= _ref ? _i++ : _i--){ _results.push(_i); }
          return _results;
        }).apply(this);
        this.tileContainer = new PIXI.DisplayObjectContainer();
        for (x = _j = 0, _ref1 = this.tiles.length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; x = 0 <= _ref1 ? ++_j : --_j) {
          this.tiles[x] = (function() {
            _results1 = [];
            for (var _k = 0, _ref2 = this.dimension; 0 <= _ref2 ? _k < _ref2 : _k > _ref2; 0 <= _ref2 ? _k++ : _k--){ _results1.push(_k); }
            return _results1;
          }).apply(this);
          for (y = _l = 0, _ref3 = this.tiles[x].length; 0 <= _ref3 ? _l < _ref3 : _l > _ref3; y = 0 <= _ref3 ? ++_l : --_l) {
            this.tiles[x][y] = new Tile("none", false, this.tileContainer, new Vector(), new Vector(), this.tilesize);
          }
        }
        this.texSize = this.tilesize * this.dimension;
        this.renderTexture = new PIXI.RenderTexture(this.texSize, this.texSize);
        this.sprite = new PIXI.Sprite();
        this.sprite.setTexture(this.renderTexture);
        this.gameContainer.addChild(this.sprite);
        posPerChunk = this.dimension * this.tilesize;
        chunkVec = new Vector(this.offset.x * posPerChunk, this.offset.y * posPerChunk);
        this.reconfigure(this.offset);
      }


      /*
       * generates chunk at new position
       * @param {vec2} @offset new chunk offset
       */

      Chunk.prototype.reconfigure = function(offset) {
        var chunkVec, pos, posPerChunk, tilePos, x, y, _i, _j, _ref, _ref1;
        this.offset = offset;
        this.chunkGen.generate(this);
        posPerChunk = this.dimension * this.tilesize;
        chunkVec = new Vector(this.offset.x * posPerChunk, this.offset.y * posPerChunk);
        for (x = _i = 0, _ref = this.tiles.length; 0 <= _ref ? _i < _ref : _i > _ref; x = 0 <= _ref ? ++_i : --_i) {
          for (y = _j = 0, _ref1 = this.tiles[x].length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; y = 0 <= _ref1 ? ++_j : --_j) {
            pos = new Vector(x * this.tilesize, y * this.tilesize);
            tilePos = Vector.add(chunkVec, pos);
            this.tiles[x][y].updatePos(tilePos, x * this.tilesize, y * this.tilesize);
          }
        }
        this.renderTexture.render(this.tileContainer);
        this.sprite.position.x = chunkVec.x;
        return this.sprite.position.y = chunkVec.y;
      };


      /*
       * converts a global position to tile offsets
       * @param {vec2} pos position to convert
       * @return {vec2} tile offset reltive to this tile
       */

      Chunk.prototype.toTileOffset = function(pos) {
        var p;
        p = this.tiles[0][0].pos;
        return Vector.sub(pos, p).mul(1 / this.tilesize).foreach(Math.floor);
      };


      /*
       * determines if a tile is a wall
       * @param {vec2} offset tile offset of the tile to be tested
       * @return {bool} returns bool on true
       */

      Chunk.prototype.isWall = function(offset) {
        return this.offset[x][y].isWall();
      };

      Chunk.prototype.toData = function() {
        var ch, res, x, y, _i, _j, _ref, _ref1;
        res = [];
        for (x = _i = 0, _ref = this.tiles.length; 0 <= _ref ? _i < _ref : _i > _ref; x = 0 <= _ref ? ++_i : --_i) {
          for (y = _j = 0, _ref1 = this.tiles.length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; y = 0 <= _ref1 ? ++_j : --_j) {
            ch = {
              x: x,
              y: y,
              data: this.tiles[x][y].toString()
            };
            res.push(ch);
          }
        }
        return res;
      };

      return Chunk;

    })();
  });

}).call(this);
