// Generated by CoffeeScript 1.8.0
(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  define(["vector", "chunk", "chunkGenerator"], function(Vector, Chunk, ChunkGen) {
    var Map;
    return Map = (function() {

      /*
       * represents a world of chunks
       * @param  {vec2} @position        position to generate world at (chunk units)
       * @param  {int} @chunkThreshold Threshold distance to generate or keep chunks
       * @param  {int} @chunkDim        number of tiles on each chunk axis
       * @param  {int} @tileSize        size of each tile
       */
      function Map(position, chunkThreshold, chunkDim, tileSize, gameContainer) {
        var x, y, _i, _j, _k, _l, _ref, _ref1, _ref2, _ref3, _results, _results1;
        this.position = position;
        this.chunkThreshold = chunkThreshold;
        this.chunkDim = chunkDim;
        this.tileSize = tileSize;
        this.gameContainer = gameContainer;
        this.toChunkOffset = __bind(this.toChunkOffset, this);
        this.chunkGen = new ChunkGen();
        this.chunks = (function() {
          _results = [];
          for (var _i = 0, _ref = this.chunkThreshold; 0 <= _ref ? _i < _ref : _i > _ref; 0 <= _ref ? _i++ : _i--){ _results.push(_i); }
          return _results;
        }).apply(this);
        for (x = _j = 0, _ref1 = this.chunks.length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; x = 0 <= _ref1 ? ++_j : --_j) {
          this.chunks[x] = (function() {
            _results1 = [];
            for (var _k = 0, _ref2 = this.chunkThreshold; 0 <= _ref2 ? _k < _ref2 : _k > _ref2; 0 <= _ref2 ? _k++ : _k--){ _results1.push(_k); }
            return _results1;
          }).apply(this);
          for (y = _l = 0, _ref3 = this.chunks[x].length; 0 <= _ref3 ? _l < _ref3 : _l > _ref3; y = 0 <= _ref3 ? ++_l : --_l) {
            this.chunks[x][y] = new Chunk(new Vector(this.position.x + x, this.position.y + y), this.chunkDim, this.tileSize, this.chunkGen, this.gameContainer);
          }
        }
        this.livePos = new Vector(this.tileSize * this.chunkDim * position.x, this.tileSize * this.chunkDim * position.y);
      }


      /*
       * calculates the chunk the position is placed on
       * @param  {vec2} position global position
       * @return {vec2}          chunk coordinates
       */

      Map.prototype.toChunkOffset = function(position) {
        var vector;
        vector = new Vector(position);
        vector.mul(1 / this.tileSize);
        vector.mul(1 / this.chunkDim);
        vector.foreach(Math.floor);

        /*
        if(Vector.distSquared(new Vector(position).mul(1/@tileSize/@chunkDim).foreach(Math.floor), vector) > 0.5)
          console.log "toChuckOffset wrong"
         */
        return vector;
      };


      /*
       * moves the map by a vector and generates new chunks according to chunkThreshold
       * @param  {vec2} translation vector to move the map
       */

      Map.prototype.move = function(translation) {
        var column, diff, i, newPos, newX, newY, shift, x, y, _i, _j, _k, _l, _m, _n, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _results, _results1;
        this.livePos.add(translation);
        newPos = this.toChunkOffset(this.livePos);
        diff = Vector.sub(newPos, this.position);
        if ((diff.x !== 0) || (diff.y !== 0)) {
          this.position = new Vector(newPos);
        }
        if (diff.x !== 0) {
          if (diff.x > 0) {
            for (x = _i = 0, _ref = diff.x; _i < _ref; x = _i += 1) {
              newX = this.chunks[this.chunks.length - 1][0].offset.x + 1;
              column = this.chunks.shift();
              this.chunks.push(column);
              for (y = _j = 0, _ref1 = column.length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; y = 0 <= _ref1 ? ++_j : --_j) {
                column[y].reconfigure(new Vector(newX, this.position.y + y));
              }
            }
          } else {
            for (i = _k = 0, _ref2 = -diff.x; _k < _ref2; i = _k += 1) {
              newX = this.chunks[0][0].offset.x - 1;
              column = this.chunks.pop();
              this.chunks.unshift(column);
              for (y = _l = 0, _ref3 = column.length; 0 <= _ref3 ? _l < _ref3 : _l > _ref3; y = 0 <= _ref3 ? ++_l : --_l) {
                column[y].reconfigure(new Vector(newX, this.position.y + y));
              }
            }
          }
        }
        if (diff.y !== 0) {
          if (diff.y < 0) {
            _results = [];
            for (x = _m = 0, _ref4 = this.chunks.length; _m < _ref4; x = _m += 1) {
              column = this.chunks[x];
              _results.push((function() {
                var _n, _ref5, _results1;
                _results1 = [];
                for (y = _n = 0, _ref5 = -diff.y; _n < _ref5; y = _n += 1) {
                  newY = column[0].offset.y - 1;
                  shift = column.pop();
                  column.unshift(shift);
                  _results1.push(shift.reconfigure(new Vector(this.position.x + x, newY)));
                }
                return _results1;
              }).call(this));
            }
            return _results;
          } else {
            _results1 = [];
            for (x = _n = 0, _ref5 = this.chunks.length; _n < _ref5; x = _n += 1) {
              column = this.chunks[x];
              _results1.push((function() {
                var _o, _ref6, _results2;
                _results2 = [];
                for (y = _o = 0, _ref6 = diff.y; _o < _ref6; y = _o += 1) {
                  newY = column[this.chunks[0].length - 1].offset.y + 1;
                  shift = column.shift();
                  column.push(shift);
                  _results2.push(shift.reconfigure(new Vector(this.position.x + x, newY)));
                }
                return _results2;
              }).call(this));
            }
            return _results1;
          }
        }
      };

      Map.prototype.toString = function() {
        var ch, res, x, y, _i, _j, _ref, _ref1;
        res = {
          position: this.position,
          chunkThreshold: this.chunkThreshold,
          chunkDim: this.chunkDim,
          tileSize: this.tileSize,
          chunks: []
        };
        for (x = _i = 0, _ref = this.chunks.length; 0 <= _ref ? _i < _ref : _i > _ref; x = 0 <= _ref ? ++_i : --_i) {
          for (y = _j = 0, _ref1 = this.chunks.length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; y = 0 <= _ref1 ? ++_j : --_j) {
            ch = {
              x: x,
              y: y,
              data: this.chunks[x][y].toData()
            };
            res.chunks.push(ch);
          }
        }
        return JSON.stringify(res);
      };

      return Map;

    })();
  });

}).call(this);
